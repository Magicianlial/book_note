---------------------------构造、析构、赋值-------------------------------
条款1：视c++为一个语言联邦
次语言：
1. C
2. Object-Oriented C++，面向对象，C with Classes
3. Template C++ ，泛型编程
4. STL， template程序块
-------------------------------------------------------------
条款2：尽量以const,enum,inline替换#define
“宁可以编译器替换预处理器”
1.对于单纯常量，最好以const对象或enums替换#define(宏的问题，报错不准确，容易报对应常量的错，难以debug；#define不重视作用域，没有封装性，不能定义class等)
2.对于形似函数的宏，最好改用inline函数体寒#define（宏的问题，实参小括号严格，前置递增敏感）
-------------------------------------------------------------
条款3： 尽可能使用const
#降低不正当操作的错误
#常函数() cosnt，不能修改成员的值，除非成员设置为 mutable(可变的)
#non-const版本 调用 const版本(可以避免代码重复)避免递归调用自己，二次转型
static_cast<const T&>(*this) 安全转型，非常量转成常量，增加const
const_cast<char&>(...) 移除const
-------------------------------------------------------------
条款4：确定对象被使用前已经初始化
#类内构造函数初始化：A::A(int &x): a(x) {} (成员初值列,相比与赋值版本，类内声明构造函数，类外赋值，赋值版本成员对象首先设初值，然后再赋予新值，default构造函数的一切浪费了)


#构造函数：C++用于构建类的新对象时需要调用的函数，该函数无返回类型！（注意：是“无”！ 不是空！(void)）。

#默认构造函数：未提供显式初始值时，用来创建对象的构造函数。（就是给个默认值呗）

#不同编译单元（产出单一目标文件的源码，由单一源码+含入头文件组成）内的non-local static 对象初始化相对顺序无明确定义。处理方法：non-local static->local static,单例模式（singleton），将每个non-local static对象搬到自己的专属函数内（声明为static“通用函数”）返回一个reference指向他所含的对象，用户调用这些函数而不直接指涉这些对象。(cpp保证函数内的local static对象会在调用期间先被初始化)

1.为内置型对象手动初始化，cpp不保证初始化他们。
2.构造函数最好使用成员初值列，而不要再构造函数内使用赋值操作。初值列成员变量次序应和在class中声明次序相同。
3.为免除“跨编译单元之初始化次序”问题（不同源码文件建立的函数，顺序不一定，用到某个实参时其未初始化的问题），用local static对象替换non-local static对象。

编译器自动生成默认构造函数的四种情况：
1.内含一个成员变量，而这个成员变量所属的类中含有默认构造函数，则此时需要为此类生成一个implicit default constructor(隐式的默认构造函数),这个implicit default constructor是nontrivial的，因为内含的成员变量需要进行默认构造操作。

如果内含一个成员变量a，且该成员变量a含有默认构造函数。同时已经对该类定义了默认构造函数但未对a进行操作，则编译器会在自己定义的默认构造函数的开始部分插入一个a所属类的默认构造函数，不然这个自己定义的默认构造函数将会忽视掉a的nontrival默认构造函数。

2.继承自一个类，且该类中有默认构造函数。派生类中没有定义默认构造函数，则编译器会为派生类提供一个上一层基类的默认构造函数。

3.class中声明了一个虚函数。声明了虚函数代表该class中将出现vptr，并需要为虚函数构造一张虚函数表vtbl，这个操作是必须的，因此使该class的默认构造函数成为nontrivial的，因此需要为了这个vptr和vtbl构建默认构造函数，进行初始化操作。

4.带有虚基类的class。因为虚基类的引入，必须要有一个指针或者类似索引的东西来指向虚基类的区域，以使虚基类的派生类们能找到共享的虚基类的存储区域。
-------------------------------------------------------------
条款5：了解C++默默编写并调用哪些函数
#C++的空类，编译器会加入哪些默认的成员函数
·默认构造函数和拷贝构造函数A (const A&other)
（默认构造函数（default constructor）就是在没有显式提供初始化式时调用的构造函数。它由不带参数的构造函数，或者为所有的形参提供默认实参的构造函数定义。如果定义某个类的变量时没有提供初始化时就会使用默认构造函数。）
·析构函数（只有一个，不可以被重载，无参数）
·赋值函数（赋值运算符）
·取值函数

#深拷贝与浅拷贝：
浅拷贝：如果复制的对象中引用了一个外部内容（例如分配在堆上的数据），那么在复制这个对象的时候，让新旧两个对象指向同一个外部内容，就是浅拷贝。（指针虽然复制了，但所指向的空间内容并没有复制，而是由两个对象共用）
深拷贝：如果在复制这个对象的时候为新对象制作了外部对象的独立复制，就是深拷贝。

#编译器可以暗自为class创建default构造函数，copy构造函数,copy assignment操作符,以及析构函数
-------------------------------------------------------------
条款6：若不想使用编译器自动生成的函数，就该明确拒绝
为驳回编译器自动提供的机能（拷贝构造函数，赋值函数等），可将相应的成员函数声明为private并不予实现。或者使用Uncopyable这样的base class（protected 构造和析构函数， private拷贝和赋值）
-------------------------------------------------------------
条款7：为多态基类声明virtual析构函数
#定义一个函数为虚函数，不代表函数为不被实现的函数。
定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。
定义一个函数为纯虚函数，才代表函数没有被实现。
定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数
（在基类中实现纯虚函数的方法是在函数原型后加 =0:
virtual void funtion()=0）

1.polymorphic (带多态性质的) base classes应该声明一个virtual 析构函数。如果class 带有任何virtual函数。他就应该拥有一个virtual析构函数。
2.Classes的设计目的如果不是作为base classes使用，或不是为了具备多态性，就不该声明virtual析构函数
-------------------------------------------------------------
条款8：别让异常逃离析构函数
析构函数抛出异常的问题：
假如析构函数抛出了异常，系统会变得十分危险。也许很长时间什么问题都不会发生，也许系统有时就莫名其妙的崩溃退出了，而且什么迹象也没有，让debug变得困难。

1.析构函数不要吐出异常（导致过早结束程序或发生不明确行为）。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。
2.如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非析构函数中）执行该操作。
-------------------------------------------------------------
条款9： 绝不在构造和析构过程中调用virtual函数
#在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class（比起当前执行构造函数和析构函数的那层）

非正式说法：derived构造函数先构造base,在base class构造期间,virtual函数被看做非virtual函数，直接调用（如果是纯虚函数，可能报错），他会调用基类的虚函数而不去调用派生类的虚函数。（cpp不会让基类构造过程中访问派生类，因为派生类可能还没初始化）
-------------------------------------------------------------
条款10：令operator=返回一个reference to *this
#this是c++中的隐式指针
#return *this返回的是当前对象的克隆或者本身（若返回类型为A， 则是克隆， 若返回类型为A&， 则是本身 ）。return this返回当前对象的地址（指向当前对象的指针)
令赋值（assignment）操作符返回一个reference to *this
-------------------------------------------------------------
条款11：在oprator=中处理“自我赋值”
#注意自我赋值操作时的不当情况（比如删掉再复制操作中，删除的是本体）
1.确保当对象自我赋值时operator=有良好行为。其中技术包括比较“来源对象”和目标对象的地址、精心周到的语句顺序、以及copy-and-swap。
2.确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为为仍然正确。
-------------------------------------------------------------
条款12：复制对象时勿忘其每一个成分
#自己定义的copying函数，可能只复制局部对象（自定义的那些，但基类中的对象，还有没考虑的对象没有复制，编译器也不会告诉你）。
#assignment操作符只施行于已初始化对象，若调用copy构造(试图构造已经存在的对象)
#copy构造函数构造对象，若调用赋值（对一个尚未构造好的对象进行操作）
1.copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”
2.不要尝试以某个copying函数实现另一个copying函数（不要用copy构造函数调用copy赋值，反过来也不行）。应该将共同机能放进第三个函数中，并由两个coping函数共同调用。
-------------------------------------------------------------
-----------------------------资源管理-------------------------------------
条款13：以对象管理资源
#“以对象管理资源”的观念称为“资源取得时机时便是初始化时机”（Resource Acquisition;RAII）
#auto_ptr有一个问题，若通过copy构造或赋值复制它们，它们就会变成null，而复制的指针将获得资源唯一拥有权（a = b, b = a,两个都变成null）
#auto_ptr（在c++11已被取消）替代方案是“引用计数型智慧指针”（RCSP）shared_ptr（无法打破环状引用）
1.为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源
2.两个常用的RAII classes分别是shared_ptr和auto_ptr(在cpp11中已经被unique_ptr取代）
#cpp11三种智能指针shared_ptr（计数，可指向同一）,unique_ptr（唯一对应）和weak_ptr（更像是shared_ptr的一个助手，不增加计数不具有普通指针的行为*和->，重要用途是获得this指针的shared_ptr，解决循环引用）
-------------------------------------------------------------
条款14：在资源管理类中小心coping行为

#explic(显式的，不允许隐式转换，隐式转换发生在从小->大的转换中)

1.复制RAII对象必须一并复制它所管理的资源（如果不这样，会出现A,B指向同一个底层对象，A删除后B访问错误），所以资源的copying行为决定RAII对象的copying行为。

2.普遍而常见的RAII class copying 行为是： 抑制copying、施行引用计数法（reference counting）。不过其他行为也都可能被实现。
-------------------------------------------------------------
条款15：在资源管理类中提供对原始资源的访问
#显式转换，智能指针成员函数get，返回智能指针内部的原始指针（的复件）
#隐式转换，智能指针重载了操作符，通过操作符->与*， p-> 和 (*P).

#类B中 operator A() const {return v;}
自定义类型转换， 将需要转换时B隐式转换为A

1.APIs（接口）往往要求访问原始资源（raw resources），所以每一个RAII class应该提供一个“取得其所管理之资源”的办法。
2.对原始资源的访问可能经由显示转换或隐式转换。一般而言显式转换比较安全，但隐式转换对克服比较方便。
-------------------------------------------------------------
条款16：成对使用new和delete时要采取相同形式
# delete p; //删除一个对象
# delete [ ] p; //删除一个由对象组成的数组 ，数组一定要加[ ],不然他只删除一个对象

#如果你在new表达式中使用[ ]，必须在相应的delete表达式中也使用[ ]。如果你在new表达式中不使用[ ]，一定不要再相应的delete表达式中使用[ ]。
-------------------------------------------------------------
条款17：以独立语句将newed对象置入智能指针
#就是不要在函数内形参将new写进，由于执行顺序不确定，可能你new了对象还没给智能指针，执行其他参数时发生异常，这样new就产生了资源泄露
（正确方法是不提供显示转换的new，使用分离语句，先在单独语句中以智能指针存储newed所得对象，再调用函数）
-------------------------------------------------------------
4.设计与声明
-------------------------------------------------------------
条款18：让接口容易被正确使用，不易被误用

1.正确使用：接口的一致性，与内置类型的行为兼容

2.防止误用： 建立新类型（月份1-12），限制类型上的操作（返回值const），束缚对象值， 消除客户的资源管理责任（利用shared_ptr，防止DLL问题(Dynamic Link Library的缩写,意为动态链接库)，自动解除互斥锁）

-------------------------------------------------------------
条款19：设计class犹如设计type
#创建与销毁、初始化与赋值、值传递与引用传递、合法值、继承、转换、操作符重载、private、模板等

-------------------------------------------------------------
条款20：宁以pass-by-referrence-to-const替换pass-by-value

#值传递耗费大量复制成本

#引用传递(指针实现)不会被切割(slicing)成底层类型（派生类型值传递可能会导致认成基层类型，函数参数是基类）

#特例：内置类型例如Int和STL对象适合值传递，因为它们被设计成passed by value，效率更高

-------------------------------------------------------------
条款21：必须返回对象时，不要返回其reference

#引用本身是另一对象的别名，这一对象必须存在，如果没有这个对象，或者是个临时值，就不要引用(比如操作符*函数返回值）。

-------------------------------------------------------------
条款22：将成员变量声明为private

#protected:介于private（只能自己）与pubilc（所有）之间，派生类可以使用

#public和protected（不比public更具封装）成员变量缺乏封装性，如果他们被改变，大量代码遭到破坏

#将成员变量隐藏在函数接口的背后，可以为“所有可能的实现”提供弹性，因为只有成员函数可以影响它们（读写时通知其他对象、验证class约束条件、多线程执行同步控制）

---------------------------------------------------------
条款23：宁以non-member、non-friend替换member函数

#更加具有封装性（越少对象可以看到它，封装性越强，改变其的弹性越大，因为改变只影响有限对象）

#namespace可以跨越多个源码文件而后者不能（把class和外部定义的便利函数放同一命名空间）



































