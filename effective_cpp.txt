---------------------------构造、析构、赋值-------------------------------
条款1：视c++为一个语言联邦
次语言：
1. C
2. Object-Oriented C++，面向对象，C with Classes
3. Template C++ ，泛型编程
4. STL， template程序块
-------------------------------------------------------------
条款2：尽量以const,enum,inline替换#define
“宁可以编译器替换预处理器”
1.对于单纯常量，最好以const对象或enums替换#define(宏的问题，报错不准确，容易报对应常量的错，难以debug；#define不重视作用域，没有封装性，不能定义class等)
2.对于形似函数的宏，最好改用inline函数替代#define（宏的问题，实参小括号严格，前置递增在三目运算符中可能递增一次可能两次）
-------------------------------------------------------------
条款3： 尽可能使用const
#降低不正当操作的错误
#常函数() cosnt，不能修改成员的值，除非成员设置为 mutable(可变的)
#non-const版本 调用 const版本(可以避免代码重复)避免递归调用自己，二次转型
static_cast<const T&>(*this) 安全转型，非常量转成常量，增加const
const_cast<char&>(...) 移除const
-------------------------------------------------------------
条款4：确定对象被使用前已经初始化
#类内构造函数初始化：A::A(int &x): a(x) {} (成员初值列,相比与赋值版本，类内声明构造函数，类外赋值，赋值版本成员对象首先设初值，然后再赋予新值，default构造函数的一切浪费了)


#构造函数：C++用于构建类的新对象时需要调用的函数，该函数无返回类型！（注意：是“无”！ 不是空！(void)）。

#默认构造函数：未提供显式初始值时，用来创建对象的构造函数。（就是给个默认值呗）

#不同编译单元（产出单一目标文件的源码，由单一源码+含入头文件组成）内的non-local static 对象初始化相对顺序无明确定义。处理方法：non-local static->local static,单例模式（singleton），将每个non-local static对象搬到自己的专属函数内（声明为static“通用函数”）返回一个reference指向他所含的对象，用户调用这些函数而不直接指涉这些对象。(cpp保证函数内的local static对象会在调用期间先被初始化)

1.为内置型对象手动初始化，cpp不保证初始化他们。
2.构造函数最好使用成员初值列，而不要再构造函数内使用赋值操作。初值列成员变量次序应和在class中声明次序相同。
3.为免除“跨编译单元之初始化次序”问题（不同源码文件建立的函数，顺序不一定，用到某个实参时其未初始化的问题），用local static对象替换non-local static对象。

编译器自动生成默认构造函数的四种情况：
1.内含一个成员变量，而这个成员变量所属的类中含有默认构造函数，则此时需要为此类生成一个implicit default constructor(隐式的默认构造函数),这个implicit default constructor是nontrivial的，因为内含的成员变量需要进行默认构造操作。

如果内含一个成员变量a，且该成员变量a含有默认构造函数。同时已经对该类定义了默认构造函数但未对a进行操作，则编译器会在自己定义的默认构造函数的开始部分插入一个a所属类的默认构造函数，不然这个自己定义的默认构造函数将会忽视掉a的nontrival默认构造函数。

2.继承自一个类，且该类中有默认构造函数。派生类中没有定义默认构造函数，则编译器会为派生类提供一个上一层基类的默认构造函数。

3.class中声明了一个虚函数。声明了虚函数代表该class中将出现vptr，并需要为虚函数构造一张虚函数表vtbl，这个操作是必须的，因此使该class的默认构造函数成为nontrivial的，因此需要为了这个vptr和vtbl构建默认构造函数，进行初始化操作。

4.带有虚基类的class。因为虚基类的引入，必须要有一个指针或者类似索引的东西来指向虚基类的区域，以使虚基类的派生类们能找到共享的虚基类的存储区域。
-------------------------------------------------------------
条款5：了解C++默默编写并调用哪些函数
#C++的空类，编译器会加入哪些默认的成员函数
·默认构造函数和拷贝构造函数A (const A&other)
（默认构造函数（default constructor）就是在没有显式提供初始化式时调用的构造函数。它由不带参数的构造函数，或者为所有的形参提供默认实参的构造函数定义。如果定义某个类的变量时没有提供初始化时就会使用默认构造函数。）
·析构函数（只有一个，不可以被重载，无参数）
·赋值函数（赋值运算符）
·取值函数

#深拷贝与浅拷贝：
浅拷贝：如果复制的对象中引用了一个外部内容（例如分配在堆上的数据），那么在复制这个对象的时候，让新旧两个对象指向同一个外部内容，就是浅拷贝。（指针虽然复制了，但所指向的空间内容并没有复制，而是由两个对象共用）
深拷贝：如果在复制这个对象的时候为新对象制作了外部对象的独立复制，就是深拷贝。

#编译器可以暗自为class创建default构造函数，copy构造函数,copy assignment操作符,以及析构函数
-------------------------------------------------------------
条款6：若不想使用编译器自动生成的函数，就该明确拒绝
为驳回编译器自动提供的机能（拷贝构造函数，赋值函数等），可将相应的成员函数声明为private并不予实现。或者使用Uncopyable这样的base class（protected 构造和析构函数， private拷贝和赋值）
-------------------------------------------------------------
条款7：为多态基类声明virtual析构函数
#定义一个函数为虚函数，不代表函数为不被实现的函数。
定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。
定义一个函数为纯虚函数，才代表函数没有被实现。
定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数
（在基类中实现纯虚函数的方法是在函数原型后加 =0:
virtual void funtion()=0）

1.polymorphic (带多态性质的) base classes应该声明一个virtual 析构函数。如果class 带有任何virtual函数。他就应该拥有一个virtual析构函数。
2.Classes的设计目的如果不是作为base classes使用，或不是为了具备多态性，就不该声明virtual析构函数
-------------------------------------------------------------
条款8：别让异常逃离析构函数
析构函数抛出异常的问题：
假如析构函数抛出了异常，系统会变得十分危险。也许很长时间什么问题都不会发生，也许系统有时就莫名其妙的崩溃退出了，而且什么迹象也没有，让debug变得困难。

1.析构函数不要吐出异常（导致过早结束程序或发生不明确行为）。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。
2.如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非析构函数中）执行该操作。
-------------------------------------------------------------
条款9： 绝不在构造和析构过程中调用virtual函数
#在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class（比起当前执行构造函数和析构函数的那层）

非正式说法：derived构造函数先构造base,在base class构造期间,virtual函数被看做非virtual函数，直接调用（如果是纯虚函数，可能报错），他会调用基类的虚函数而不去调用派生类的虚函数。（cpp不会让基类构造过程中访问派生类，因为派生类可能还没初始化）
-------------------------------------------------------------
条款10：令operator=返回一个reference to *this
#this是c++中的隐式指针
#return *this返回的是当前对象的克隆或者本身（若返回类型为A， 则是克隆， 若返回类型为A&， 则是本身 ）。return this返回当前对象的地址（指向当前对象的指针)
令赋值（assignment）操作符返回一个reference to *this
-------------------------------------------------------------
条款11：在oprator=中处理“自我赋值”
#注意自我赋值操作时的不当情况（比如删掉再复制操作中，删除的是本体）
1.确保当对象自我赋值时operator=有良好行为。其中技术包括比较“来源对象”和目标对象的地址、精心周到的语句顺序、以及copy-and-swap。
2.确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为为仍然正确。
-------------------------------------------------------------
条款12：复制对象时勿忘其每一个成分
#自己定义的copying函数，可能只复制局部对象（自定义的那些，但基类中的对象，还有没考虑的对象没有复制，编译器也不会告诉你）。
#assignment操作符只施行于已初始化对象，若调用copy构造(试图构造已经存在的对象)
#copy构造函数构造对象，若调用赋值（对一个尚未构造好的对象进行操作）
1.copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”
2.不要尝试以某个copying函数实现另一个copying函数（不要用copy构造函数调用copy赋值，反过来也不行）。应该将共同机能放进第三个函数中，并由两个coping函数共同调用。
-------------------------------------------------------------
-----------------------------资源管理-------------------------------------
条款13：以对象管理资源
#“以对象管理资源”的观念称为“资源取得时机时便是初始化时机”（Resource Acquisition;RAII）
#auto_ptr有一个问题，若通过copy构造或赋值复制它们，它们就会变成null，而复制的指针将获得资源唯一拥有权（a = b, b = a,两个都变成null）
#auto_ptr（在c++11已被取消）替代方案是“引用计数型智慧指针”（RCSP）shared_ptr（无法打破环状引用）
1.为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源
2.两个常用的RAII classes分别是shared_ptr和auto_ptr(在cpp11中已经被unique_ptr取代）
#cpp11三种智能指针shared_ptr（计数，可指向同一）,unique_ptr（唯一对应）和weak_ptr（更像是shared_ptr的一个助手，不增加计数不具有普通指针的行为*和->，重要用途是获得this指针的shared_ptr，解决循环引用）
-------------------------------------------------------------
条款14：在资源管理类中小心coping行为

#explic(显式的，不允许隐式转换，隐式转换发生在从小->大的转换中)

1.复制RAII对象必须一并复制它所管理的资源（如果不这样，会出现A,B指向同一个底层对象，A删除后B访问错误），所以资源的copying行为决定RAII对象的copying行为。

2.普遍而常见的RAII class copying 行为是： 抑制copying、施行引用计数法（reference counting）。不过其他行为也都可能被实现。
-------------------------------------------------------------
条款15：在资源管理类中提供对原始资源的访问
#显式转换，智能指针成员函数get，返回智能指针内部的原始指针（的复件）
#隐式转换，智能指针重载了操作符，通过操作符->与*， p-> 和 (*P).

#类B中 operator A() const {return v;}
自定义类型转换， 将需要转换时B隐式转换为A

1.APIs（接口）往往要求访问原始资源（raw resources），所以每一个RAII class应该提供一个“取得其所管理之资源”的办法。
2.对原始资源的访问可能经由显示转换或隐式转换。一般而言显式转换比较安全，但隐式转换对克服比较方便。
-------------------------------------------------------------
条款16：成对使用new和delete时要采取相同形式
# delete p; //删除一个对象
# delete [ ] p; //删除一个由对象组成的数组 ，数组一定要加[ ],不然他只删除一个对象

#如果你在new表达式中使用[ ]，必须在相应的delete表达式中也使用[ ]。如果你在new表达式中不使用[ ]，一定不要再相应的delete表达式中使用[ ]。
-------------------------------------------------------------
条款17：以独立语句将newed对象置入智能指针
#就是不要在函数内形参将new写进，由于执行顺序不确定，可能你new了对象还没给智能指针，执行其他参数时发生异常，这样new就产生了资源泄露
（正确方法是不提供显示转换的new，使用分离语句，先在单独语句中以智能指针存储newed所得对象，再调用函数）
-------------------------------------------------------------
4.设计与声明
-------------------------------------------------------------
条款18：让接口容易被正确使用，不易被误用

1.正确使用：接口的一致性，与内置类型的行为兼容

2.防止误用： 建立新类型（月份1-12），限制类型上的操作（返回值const），束缚对象值， 消除客户的资源管理责任（利用shared_ptr，防止DLL问题(Dynamic Link Library的缩写,意为动态链接库)，自动解除互斥锁）

-------------------------------------------------------------
条款19：设计class犹如设计type
#创建与销毁、初始化与赋值、值传递与引用传递、合法值、继承、转换、操作符重载、private、模板等

-------------------------------------------------------------
条款20：宁以pass-by-referrence-to-const替换pass-by-value

#值传递耗费大量复制成本

#引用传递(指针实现)不会被切割(slicing)成底层类型（派生类型值传递可能会导致认成基层类型，函数参数是基类）

#特例：内置类型例如Int和STL对象适合值传递，因为它们被设计成passed by value，效率更高（不一定，例如pair等，建立更耗费时间，小型数据类例如int可以值传递）

-------------------------------------------------------------
条款21：必须返回对象时，不要返回其reference

#引用本身是另一对象的别名，这一对象必须存在，如果没有这个对象，或者是个临时值，就不要引用(比如操作符*函数返回值）。

-------------------------------------------------------------
条款22：将成员变量声明为private

#protected:介于private（只能自己）与pubilc（所有）之间，派生类可以使用

#public和protected（不比public更具封装）成员变量缺乏封装性，如果他们被改变，大量代码遭到破坏

#将成员变量隐藏在函数接口的背后，可以为“所有可能的实现”提供弹性，因为只有成员函数可以影响它们（读写时通知其他对象、验证class约束条件、多线程执行同步控制）

---------------------------------------------------------
条款23：宁以non-member、non-friend替换member函数

#更加具有封装性（越少对象可以看到它，封装性越强，改变其的弹性越大，因为改变只影响有限对象）

#namespace可以跨越多个源码文件而后者不能（把class和外部定义的便利函数放同一命名空间）

---------------------------------------------------------
条款24：若所有参数都需类型转换，请为此采用non-member函数

#只有参数被列于参数列(parameter list)内，这个参数才是隐式类型转换的合格参与者。(2 * a与 a * 2，前者不行
const t operator *(const t& a)有this指针，参数只有后者）

#如果要为某个函数所有参数（包括this指针所指的隐喻参数）进行类型转换，那么这个函数必须是个non-member

---------------------------------------------------------
条款25：考虑写出一个不抛异常的swap函数

#模板为什么要特化，因为编译器认为，对于特定的类型，如果你能对某一功能更好的实现，那么就该听你的。

#模板分为类模板与函数模板，特化分为全特化与偏特化。全特化就是限定死模板实现的具体类型，偏特化就是如果这个模板有多个类型，那么只限定其中的一部分。
（例子：
全特化                                偏特化
teplate<>                           template<T>
class A<int, double>() {...     class B<int, T>() {...
）

#cpp只能偏特化类模板,不能适用于函数模板，但函数允许重载，声明另一个函数模板即可替代偏特化的需要

#重载函数需要注意，在std中添加重载函数是不允许的，比如重载swap函数
namespace std {
    template<typename T>
    // 注意 swap 后面没有尖括号，这是一个新的模板函数
    // 由于当前命名空间已经有同名函数了，所以算函数重载
    void swap(Widget<T>& a, Widget<T>& b){
        a.swap(b); 
    }
}
,正确做法是别再std命名空间添加（不要添加任何东西），在一个新的命名空间做这件事

---------------------------------------------------------
五、实现

条款26:尽可能延后变量定义式的出现时间

#高效赋值方式案例：

原版：
string A;
A = B；
（先调用默认构造函数，再赋值，默认构造的初值多余了）

改进版：
string A(B); （直接用拷贝构造函数）

---------------------------------------------------------
条款27：尽量少做转型动作

#尽量使用新式转型
旧式转型： T(a)   (T)a
新式转型：
1.const_cast 消除常量性
2.static_cast 隐式转换（例如int -> double，空指针 -> 某一类型指针）
3.dynamic_cast 继承体系，“安全向下转型”，旧式无法做到
4.reinterpret_cast 低级转型，指针到int

#尽量避免转型，必要的话封装成函数。

---------------------------------------------------------
条款28：避免返回handles（号码牌，用来取得对象）指向对象内部成分

#内部成分：成员变量、不被公开使用的成员函数（protected或Private）

#返回某些private成员的引用（或指针）会使其失去封装性，因为你可以通过指针修改它，解决措施：返回其const 类型（函数名后+const不行，虽然它的作用是不能对成员数据做任何改动，它确实没修改但返回了指针）

#返回引用可能导致空悬指针，因为可能获得临时对象，这个对象随后就销毁了，但是你的生存周期比他长。

---------------------------------------------------------
条款29：为“异常安全”而努力是值得的

#“异常安全”：
1.不泄露资源 （调用时异常，一直无法释放资源）
2.不允许数据败坏（指向一个已删除的对象）

异常安全码三类保证：
1.基本保证：有异常，有效状态（在掌控内，可以恢复数据一致）
2.强烈保证：有异常，恢复原来
3.不抛掷保证：保证无异常

---------------------------------------------------------
条款30：透彻了解inlining

#含义：每一次函数调用以函数本体替换

#优点：1、免除函数调用成本。2、编译器最优化机制会优化inline函数（针对“不含函数调用”的代码，对Outlined函数一般不会执行最优化）

#缺点：
1、增加目标码，代码膨胀导致额外换页行为，降低指令高速缓存装置的集中率，以及效率损失。
2、无法随着程序库的升级而升级，一旦要改变f，所有用到f的客户端程序都需要重新编译，如果不是Inline f,客户端只需要在f修改后重新连接就可以。

#Inline只是申请，不是强制命令

#类内成员函数（类内实现的，类外实现不算，而且只是建议编译器，不是强制）默认内联

#inline是编译期行为，通常放在头文件，适用小型、频繁调用的函数

#virtual意味等待，“直到运行期间才确定调用哪个函数”
inline是“执行前，先将动作替换为被调用函数的主体”，这两者冲突，不能用inline 修饰virtual（也不要用在构造和析构上）

---------------------------------------------------------
条款31：将文件间的编译依存关系降至最低

#编译依存：
类A中的对象需要用到头文件B,C内容，头文件改变了，任何使用类A的的文件需要重新编译（解决办法：实现和接口分离，用两个类A, Aimpl, Aimpl实现，A通过智能指针指向Aimpl）

#“编译依存性最小化”：依赖声明而非定义
两种方法：1.Handle（句柄） classes 2.Interface classes

handle class：
把一个类变为一个接口类和一个实现类 实现类就是原来的这个类，接口类就是原来这个类的接口函数（public）和 一个private的智能指针对象（一般为shared_ptr）指向实现类，接口类里面需要用到的类，我们提供给它的都是类的前向声明，所以为了严格执行这样的准则，我们把每一个类（包括接口类和实现类）都提供两个头文件，一个是类的声明 xxfwd.h 一个是类的定义 xx.h 
优点：1.解决递归依赖 2.只需要修改iml.h
缺点：通过指针访问数据，增加指针内存、动态内存分配的管理开销和bad_alloc异常的处理难度

interface class 
原来一个A类，让它的接口成为一个抽象基类 class A，具体是 接口函数都定义成为 纯虚函数,  析构函数是虚函数，还有一个static工厂函数 create 返回shared_ptr<A> 
它的实现成为派生类  Aimpl，这样改变A类的实现，就改变Aimpl的实现就ok了
客户用的时候只能  shared_ptr<A>  Aptr(A::create(参数) ) ; 这样用


#头文件应该“完全且仅有声明式”（实现分离）

---------------------------------------------------------
六、继承与面向对象设计

条款32：确定你的public继承塑模出is-a（是一种）关系

#public继承，派生类可以实现基类的所有功能。（学生-人）

---------------------------------------------------------
条款33：避免遮掩继承而来的名称

#派生类先在当前类内找对象，找不到对象再去基类找（嵌套关系，类似局部变量和外部变量），重名掩盖（不是重载是掩盖了）
解决措施：
1.using 声明 using 基类:: 重名函数 
2.只想要特定版本的一个，而不是所有同名函数，利用转交函数，隐式inline如 virtual void f1() {Base::f1();}

---------------------------------------------------------
条款34：区分接口继承和实现继承

#基类的派生
1.纯虚函数，基类不实现，子类必须实现，接口继承
2.虚函数，基类实现，子类可以用基类，也可以自己写，接口和缺省实现继承。
3.非虚函数，基类实现，子类不变动直接用基类，接口继承和强制实现继承

---------------------------------------------------------
条款35：考虑virtual函数以外的其他选择

#Template Method设计模式：
non-virtual interface(NVI)，以public non-virtual成员函数包裹较低访问性（private或protected的virtual函数）

#Strategy设计模式：
1.将virtual函数替换成为“函数指针成员变量”。
2.以tr1::function成员变量替换virtual函数。
3.将继承体系内的virtual函数替换成另一个继承体系内的virtual函数。

















