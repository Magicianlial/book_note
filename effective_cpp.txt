条款1：视c++为一个语言联邦
次语言：
1. C
2. Object-Oriented C++，面向对象，C with Classes
3. Template C++ ，泛型编程
4. STL， template程序块

条款2：尽量以const,enum,inline替换#define
“宁可以编译器替换预处理器”
1.对于单纯常量，最好以const对象或enums替换#define(宏的问题，报错不准确，容易报对应常量的错，难以debug；#define不重视作用域，没有封装性，不能定义class等)
2.对于形似函数的宏，最好改用inline函数体寒#define（宏的问题，实参小括号严格，前置递增敏感）

条款3： 尽可能使用const
#降低不正当操作的错误
#常函数() cosnt，不能修改成员的值，除非成员设置为 mutable(可变的)
#non-const版本 调用 const版本(可以避免代码重复)避免递归调用自己，二次转型
static_cast<const T&>(*this) 安全转型，非常量转成常量，增加const
const_cast<char&>(...) 移除const

条款4：确定对象被使用前已经初始化
#类内构造函数初始化：A::A(int &x): a(x) {} (成员初值列,相比与赋值版本，类内声明构造函数，类外赋值，赋值版本成员对象首先设初值，然后再赋予新值，default构造函数的一切浪费了)

#构造函数：C++用于构建类的新对象时需要调用的函数，该函数无返回类型！（注意：是“无”！ 不是空！(void)）。

#默认构造函数：未提供显式初始值时，用来创建对象的构造函数。（就是给个默认值呗）

#不同编译单元（产出单一目标文件的源码，由单一源码+含入头文件组成）内的non-local static 对象初始化相对顺序无明确定义。处理方法：non-local static->local static,单例模式（singleton），将每个non-local static对象搬到自己的专属函数内（声明为static“通用函数”）返回一个reference指向他所含的对象，用户调用这些函数而不直接指涉这些对象。(cpp保证函数内的local static对象会在调用期间先被初始化)
1.为内置型对象手动初始化，cpp不保证初始化他们。
2.构造函数最好使用成员初值列，而不要再构造函数内使用赋值操作。初值列成员变量次序应和在class中声明次序相同。
3.为免除“跨编译单元之初始化次序”问题，用local static对象替换non-local static对象。

条款5：了解C++默默编写并调用哪些函数
#C++的空类，编译器会加入哪些默认的成员函数
·默认构造函数和拷贝构造函数A (const A&other)
（默认构造函数（default constructor）就是在没有显式提供初始化式时调用的构造函数。它由不带参数的构造函数，或者为所有的形参提供默认实参的构造函数定义。如果定义某个类的变量时没有提供初始化时就会使用默认构造函数。）
·析构函数（只有一个，不可以被重载，无参数）
·赋值函数（赋值运算符）
·取值函数

#深拷贝与浅拷贝：
浅拷贝：如果复制的对象中引用了一个外部内容（例如分配在堆上的数据），那么在复制这个对象的时候，让新旧两个对象指向同一个外部内容，就是浅拷贝。（指针虽然复制了，但所指向的空间内容并没有复制，而是由两个对象共用）
深拷贝：如果在复制这个对象的时候为新对象制作了外部对象的独立复制，就是深拷贝。

#编译器可以暗自为class创建default构造函数，copy构造函数,copy assignment操作符,以及析构函数

条款6：若不想使用编译器自动生成的函数，就该明确拒绝
为驳回编译器自动提供的机能（拷贝构造函数，赋值函数等），可将相应的成员函数声明为private并不予实现。或者使用Uncopyable这样的base class（protected 构造和析构函数， private拷贝和赋值）

条款7：为多态基类声明virtual析构函数
#定义一个函数为虚函数，不代表函数为不被实现的函数。
定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。
定义一个函数为纯虚函数，才代表函数没有被实现。
定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数
（在基类中实现纯虚函数的方法是在函数原型后加 =0:
virtual void funtion()=0）

1.polymorphic (带多态性质的) base classes应该声明一个virtual 析构函数。如果class 带有任何virtual函数。他就应该拥有一个virtual析构函数。
2.Classes的设计目的如果不是作为base classes使用，或不是为了具备多态性，就不该声明virtual析构函数

条款8：别让异常逃离析构函数
析构函数抛出异常的问题：
假如析构函数抛出了异常，系统会变得十分危险。也许很长时间什么问题都不会发生，也许系统有时就莫名其妙的崩溃退出了，而且什么迹象也没有，让debug变得困难。

1.析构函数不要吐出异常（导致过早结束程序或发生不明确行为）。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。
2.如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非析构函数中）执行该操作。